<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Meilisearch Blog]]></title><description><![CDATA[ Stories of an open source company]]></description><link/> https://blog.meilisearch.com/<image/><url> https://blog.meilisearch.com/favicon.png</url><title>美丽搜索博客</title><link/>https://blog.meilisearch.com/<generator>幽灵5.49</generator><lastbuilddate> 2023 年 5 月 30 日星期二 09:45:38 GMT </lastbuilddate><atom:link href="https://blog.meilisearch.com/rss/" rel="self" type="application/rss+xml"></atom:link><ttl> 60 </ttl><item><title><![CDATA[Minipouce.fr provides a top-grade customer experience with Meilisearch's open-source offering]]></title><description><![CDATA[With Meilisearch, Minipouce.fr can maintain its commitment to delivering the best possible user experience.]]></description><link/> https://blog.meilisearch.com/minipouce-top-grade-customer-experience/<guid ispermalink="false"> 646dd72c73432300019b4f59 </guid><category><![CDATA[Customers]]></category><dc:creator><![CDATA[Maya Shin]]></dc:creator><pubDate> Tue, 30 May 2023 09:45:13 GMT</pubDate> <media:content medium="image" url="https://blog.meilisearch.com/content/images/2023/05/minipouce-customer-experience-cover.png"></media:content><content:encoded><![CDATA[<img src="https://blog.meilisearch.com/content/images/2023/05/minipouce-customer-experience-cover.png" alt="Minipouce.fr provides a top-grade customer experience with Meilisearch&apos;s open-source offering"><p> <a href="https://www.minipouce.fr/?ref=blog.meilisearch.com">Minipouce.fr</a>是一个在线平台，可以让未来的父母创建婴儿登记表，这是准父母希望收到的礼物清单。借助包含超过 150,000 种产品的多品牌目录，Minipouce.fr 旨在为其用户提供直观且极​​其流畅的导航，确保一切都易于找到。</p><p><strong>通过选择 Meil​​isearch 作为其市场的搜索支柱，Minipouce.fr 能够保持其提供最佳用户体验的承诺。</strong> </p><figure class="kg-card kg-image-card"><img src="https://blog.meilisearch.com/content/images/2023/05/gif-minipouce.gif" class="kg-image" alt="Minipouce.fr 通过 Meil​​isearch 的开源产品提供一流的客户体验" loading="lazy" width="600" height="270" srcset="https://blog.meilisearch.com/content/images/2023/05/gif-minipouce.gif 600w"></figure><div class="kg-card kg-callout-card kg-callout-card-grey"><div class="kg-callout-emoji"> 💡</div><div class="kg-callout-text"> <em>“作为用户，与我尝试过的其他解决方案相比，它感觉就像魔法一样。我不确定它是否与错误容忍的工作方式或默认配置有关。不过，在没有特别调整的情况下设置 Meil​​isearch 后，我得到了非常相关的结果。” - Anthony Catel，Minipouce 的联合创始人</em><a href="https://www.minipouce.fr/?ref=blog.meilisearch.com"><em>。</em></a></div></div><h3 id="challenge">挑战</h3><p>作为父母，Minipouce.fr 的联合创始人非常熟悉新父母所面临的困难。至关重要的是创建一个多品牌婴儿登记清单，使亲朋好友能够在一个地点从多个分销商处购物，而不是局限于一个单一的供应商。</p><p>启动一个新的市场是一项复杂的任务：您需要产生足够的流量来说服分销商首先列出他们的产品。另一方面，您需要多样化和广泛的目录才能吸引客户并推动流量。</p><p>对于联合创始人兼工程主管 Anthony Catel 来说，Minipouce.fr 显然需要从一开始就提供有竞争力的高质量用户体验。增强像 Minipouce.fr 这样的平台的搜索功能很重要：更相关的搜索结果会导致用户购买量增加，这反过来又允许 Minipouce.fr 从其平台上的每一件产品购买中收取附属费用。为实现这一目标，该平台背后的技术必须是一流的，并通过合并含义层以适应用户可能使用的各种搜索词来实现更快、更顺畅的产品选择。</p><p>更复杂的是，每个零售商都倾向于为其产品目录使用不同的格式，这导致 Minipouce.fr 随后需要解决的信息不匹配和缺失。同义词也起着至关重要的作用，因为一种产品可以有多个名称，而客户可能只熟悉其中一个。如果不考虑所有潜在同义词的搜索，用户可能找不到合适的产品。</p><p>所有这些错综复杂的问题都需要借助最合适的搜索解决方案来解决。</p><h3 id="why-minipoucefr-chose-meilisearch">为什么Minipouce.fr选择了美丽搜索<br></h3><ol><li><strong>更高的开箱即用相关性</strong></li></ol><p>一开始，Minipouce.fr 考虑使用 Algolia，但找不到适合这个年轻、快速发展的平台的计划。在寻找替代方案时，安东尼发现了 Typesense 并对其进行了广泛的测试。经过一组初始测试后，他决定继续寻找另一种解决方案，与 Typesense 相比，这种解决方案可以在搜索结果中提供更高的相关性。最终，Minipouce.fr 遇到了 Meil​​isearch，发现其默认配置在测试阶段显示出比 Typesense<strong>更高的搜索结果相关性</strong>，而无需任何额外调整。</p><p> 2.<strong>维护成本低</strong></p><p>Anthony 选择不考虑 ElasticSearch 或类似的解决方案，因为他希望避免管理大量 Java 依赖项。此外，他还被魅力搜索的开源平台所吸引，该平台基于<strong>Rust 运行，与竞争对手主要使用的 C++ 相比，这是一种现代语言</strong>。这种选择减少了花在调试和基础设施维护上的时间，这对于小型团队来说是一个关键因素。</p><p> 3. <strong>Melisearch 的支持和服务支持其开源产品</strong></p><p>Minipouce.fr 的业务风险很高，搜索结果的质量也很重要，因此寻求可靠、维护良好的解决方案。借助 Meil​​isearch 的开源引擎，票据和提交的有组织处理暗示了一个成熟的业务支持它。</p><h3 id="implementation">执行</h3><p>如今，Minipouce.fr 使用 Docker 在专用服务器上自行托管 Meil​​isearch，确保每项服务都是容器化的。从 Typesense 到 Meil​​isearch 的开源产品的市场迁移在半天内完成，使其成为一个快速高效的过程。 Anthony 特别赞赏多种编程语言的不同 SDK 的可用性，包括 Python SDK。此功能使 Meil​​isearch 成为他的技术堆栈的自然补充，因为它有助于平台的设置，而无需额外资源。</p><p>为了进一步优化搜索体验，使用美力搜索实施了额外的调整。这包括根据受欢迎程度对目录中的某些项目进行优先排序的排序功能。实时推送更新，确保搜索结果始终是最新的。</p><h3 id="results">结果</h3><p><a href="https://www.minipouce.fr/?ref=blog.meilisearch.com">Minipouce.fr</a>对<strong>美丽搜索的无缝集成和低维护要求</strong>感到满意，这要归功于其从一开始就有效运行的默认配置。搜索结果的相关性令人印象深刻，超过了其他经过测试的替代解决方案的性能。最重要的是，自实施 Meil​​isearch 以来，Minipouce.fr 发现其平台上的搜索量增长了 5 倍。<br></p><p>展望未来，Minipouce.fr 设想了更大的可能性，例如实施矢量搜索，这将实现搜索之间的智能连接，进一步提升搜索体验。考虑到未来，Minipouce 看到了迁移到 Meil​​isearch 的云产品以外包基础架构维护的潜在好处，从而提高效率和可扩展性。</p><p><br></p> ]]>; </content:encoded></item><item><title><![CDATA[Nine reasons why Postgres might not be good enough for full text search]]></title><description><![CDATA[An overview of 9 areas where Postgres full text search falls short compared to search-focused databases.]]></description><link/> https://blog.meilisearch.com/postgres-full-text-search-limitations/<guid ispermalink="false"> 646b94f91288880001725da0 </guid><category><![CDATA[State of search]]></category><dc:creator><![CDATA[Laurent Cazanove]]></dc:creator><pubDate>Mon, 22 May 2023 16:44:25 GMT</pubDate> <media:content medium="image" url="https://blog.meilisearch.com/content/images/2023/05/postgres.png"></media:content><content:encoded><![CDATA[<img src="https://blog.meilisearch.com/content/images/2023/05/postgres.png" alt="Nine reasons why Postgres might not be good enough for full text search"><p>全文搜索是指将部分或全部文本查询与存储在数据库中的文档进行匹配。与传统的数据库查询相比，全文搜索即使在部分匹配的情况下也能提供结果。它允许为用户构建更灵活的搜索界面，从而使他们能够更快地找到准确的结果。</p><p>从简单的应用内搜索到浏览庞大的电子商务目录，全文搜索用例数不胜数。 Postgres 和其他关系数据库包含用于全文搜索的专用 API 非常普遍。不幸的是，Postgres 在多个领域都没有以搜索为中心的数据库。</p><h2 id="1-complex-setup"> 1. 设置复杂</h2><p>为了提供相关的结果，全文搜索应该容忍拼写错误，允许同义词，并允许部分匹配。此外，结果排名需要高度可定制，以适应企业的特定需求。在 Postgres 上配置全文搜索是以<a href="https://rachbelaid.com/postgres-full-text-search-is-good-enough/?ref=blog.meilisearch.com">全面配置</a>为代价的，并且通常需要在使用托管云服务时无法使用的扩展。</p><p>创建数据库索引、编写查询和排名算法很快就超越了领域知识，需要搜索、索引和语言学方面的专业知识。当解决旨在应对 Postgres 全文搜索限制的混合匹配扩展的约束时，性能优化变得更加困难。</p><p>相反，以搜索为中心的数据库具有最先进的功能，如错字容错、前缀搜索、模糊匹配、同义词和开箱即用的可定制排名。</p><h2 id="2-faceted-search"> 2.分面搜索</h2><p>分面搜索允许用户按大类细化搜索结果。它通常用于电子商务应用程序。例如，一家服装店可以按品牌、尺码或评级范围等方面实施过滤。</p><figure class="kg-card kg-image-card kg-card-hascaption"> <a href="https://ecommerce.meilisearch.com/?ref=blog.meilisearch.com"><img src="https://blog.meilisearch.com/content/images/2023/03/ecommerce-demo-4-final-1.gif" class="kg-image" alt="Postgres 可能不足以进行全文搜索的九个原因" loading="lazy"></a><figcaption>电子商务网站上的分面搜索（<a href="https://ecommerce.meilisearch.com/?ref=blog.meilisearch.com">参见演示</a>）</figcaption></figure><p>对于单个方面来说，实现过滤已经足够棘手了。但是分面可以有多种形式：类别标签、价格范围或最低评级。对所有类型实施过滤非常具有挑战性。无论如何，要实现的最棘手的查询是聚合结果以构建方面计数。这在大型数据集上变得非常耗费资源。</p><p>使用 Postgres 实现分面搜索的复杂性随着分面的数量呈指数级增长。单是分面搜索就为<a href="https://blog.meilisearch.com/why-should-you-use-meilisearch-over-elasticsearch/">Elasticsearch 或 Meil​​isearch 等</a>搜索引擎提供了强大的卖点。它们带有经过优化的一流 API 来处理分面过滤和计数。</p><h2 id="3-typo-tolerance"> 3.错字容忍度</h2><p>默认情况下，Postgres 全文搜索无法处理拼写错误。用户通常安装<code>pg_trgm</code>扩展来解决这个限制。 （同样，这个解决方案在托管 Postgres 中并不总是可用。）这个扩展特别引入了新的运算符来比较字符串之间的相似性以及搜索优化的 GIN 和 GIST 索引。</p><p>新索引允许对全文搜索进行更多配置，但在 GIN 和 GIST 索引之间进行选择并不总是那么简单。此外，新的运算符不考虑单词接近度、空格分隔符或单词大小。尤其是，这使得很难用 Postgres 实现真正的模糊匹配。</p><p>理想情况下，以搜索为中心的数据库应该允许为单词查询和多词查询配置不同的规则。美力搜索就是这种情况，它允许完全禁用特定字段的拼写错误。这使用户能够通过唯一标识符进行搜索，例如图书的<em>国际标准书号</em>( <em>ISBN</em> )。</p><figure class="kg-card kg-image-card kg-card-hascaption"> <a href="https://typo-tolerance.meilisearch.com/?ref=blog.meilisearch.com"><img src="https://blog.meilisearch.com/content/images/2022/05/typo-tolerance-2-gif.gif" class="kg-image" alt="Postgres 可能不足以进行全文搜索的九个原因" loading="lazy"></a><figcaption> ISBN 字段的拼写错误容忍度被禁用（<a href="https://typo-tolerance.meilisearch.com/?ref=blog.meilisearch.com">参见演示</a>）</figcaption></figure><h2 id="4-language-support"> 4.语言支持</h2><p>使用拉丁字母的语言与其他语言（如阿拉伯语或中文）之间的语言特性差异很大。从 Postgres 15 开始，全文搜索词典无法用于简体中文和繁体中文、韩语和日语等。这意味着求助于不同语言的特定实现。</p><div class="kg-card kg-callout-card kg-callout-card-grey"><div class="kg-callout-emoji"> 💡</div><div class="kg-callout-text">要查看<a href="https://gist.github.com/Strift/3155b9238bac6495d4cd57b83d78415f?ref=blog.meilisearch.com">Postgres 全文搜索支持的语言列表</a>，您可以在 Postgres 中运行 `\dFd` 命令。</div></div><p>在用户无法访问文件系统的 Amazon RDS 等托管环境中，语言支持限制被放大。这种受限访问阻止他们实施自定义词典、词干分析器、同义词等。</p><p>除了所有使用空格分隔单词的语言之外，美丽搜索还<a href="https://www.meilisearch.com/docs/learn/what_is_meilisearch/language?ref=blog.meilisearch.com">优化了对中文、日语、韩语、希伯来语等语言的支持</a>。</p><div class="kg-card kg-callout-card kg-callout-card-grey"><div class="kg-callout-emoji"> 🤗</div><div class="kg-callout-text">得益于其充满活力的开源社区，美力搜索受益于母语人士对<a href="https://blog.meilisearch.com/improving-meilisearchs-language-support/">改进特定语言功能</a>的贡献。</div></div><h2 id="5-paying-the-backend-price"> 5.支付后台价格</h2><p>Postgres 是一个旨在与服务器端语言进行通信的数据库。在构建面向公众的客户端应用程序时，这意味着在数据库之上构建 API 以与客户端通信。除了额外的开发时间之外，创建这样的代理还会带来更多问题。</p><p>首先是延迟问题：在返回结果之前向查询数据库的 API 发出请求必然需要一些时间。这不会影响专用搜索引擎，因为它们带有旨在向最终用户提供数据的公共 API。</p><p>现在是第二个问题：安全性。搜索引擎 API 从一开始就是为公众消费而设计的。安全性已融入该用例。默认情况下，API 密钥限制搜索请求，而<a href="https://www.meilisearch.com/docs/learn/security/tenant_tokens?ref=blog.meilisearch.com#tenant-token-payload-reference">租户令牌等高级功能支持多租户</a>。</p><figure class="kg-card kg-image-card kg-card-hascaption"> <a href="https://tenant-token.meilisearch.com/?ref=blog.meilisearch.com"><img src="https://blog.meilisearch.com/content/images/2022/04/meili-create-token.gif" class="kg-image" alt="Postgres 可能不足以进行全文搜索的九个原因" loading="lazy"></a><figcaption>使用租户令牌来限制对文档的访问（<a href="https://tenant-token.meilisearch.com/?ref=blog.meilisearch.com">参见演示</a>）</figcaption></figure><h2 id="6-scaling-limitations"> 6.缩放限制</h2><p>想要将所有数据保存在一个数据库中是有正当动机的。但是在主数据库中拥有与搜索相关的数据会带来巨大的技术后果。大型数据集上的全文搜索查询使用 Postgres 变得成本高昂，尤其是在对结果进行排名和计算方面计数时。</p><p>单体数据库常常成为需要扩展的应用程序的瓶颈。如果可以避免，请不要为此资源添加不必要的搜索相关成本。在构建面向用户的高流量应用程序时，这些成本只会成倍增加。</p><p>与关系型数据库不同，<a href="https://blog.meilisearch.com/best-practices-for-faster-indexing/">美里搜索等全文搜索引擎使用倒排索引</a>。此数据结构创建信息冗余以允许更快的信息检索。它旨在执行搜索操作，自然会在大型数据集上胜过关系数据库。而且，当搜索使用量激增时，只有一项服务需要扩展。</p><h2 id="7-relevancy"> 7.相关性</h2><p>正如我们之前提到的，相关搜索需要错字容忍度、自定义排名和同义词。在现代应用程序中，用户希望结果在每次击键时更新，这需要<a href="https://www.meilisearch.com/docs/learn/advanced/prefix?ref=blog.meilisearch.com">前缀搜索</a>。但是 Postgres 全文搜索<code>ts_rank</code>函数只允许属性加权。使用<code>pg_trgm</code>扩展时，开发人员只能根据相似性实现自己的排序。</p><p>在以搜索为中心的数据库中，结果排名、属性优先级、单词匹配数和查询的准确性等概念是一流的概念。它们与允许显式微调搜索行为的高级 API 相匹配。这使得非技术的业务利益相关者可以更轻松地使用这些概念。这被认为<a href="https://blog.meilisearch.com/bookshop-increases-search-based-purchases/">是 Bookshop 选择美力搜索</a>作为其电子商务搜索的一个关键原因。</p><h2 id="8-missing-out-on-instantsearch-libraries"> 8. 错过 InstantSearch 图书馆</h2><p>在搜索体验方面，网站和应用程序通常实现相同的用户界面模式：文本搜索栏、方面的复选框列表、范围滑块、排序菜单、页面导航等。开源 InstantSearch 库实现了所有这些这些功能以小部件的形式通过 JavaScript、iOS 和 Android 中的 SDK 提供。</p><p>当上市时间至关重要时，很难传递这样的细节。在 Algolia 的支持下，InstantSearch 库得到广泛采用，一些搜索引擎数据库带有与<a href="https://github.com/meilisearch/instant-meilisearch?ref=blog.meilisearch.com#-compatibility-with-meilisearch-and-instantsearch">InstantSearch 兼容的 API</a> 。阅读我们的 Nuxt 电子商务搜索指南，了解<a href="https://blog.meilisearch.com/nuxt-ecommerce-search-guide/">如何使用 Vue 实现 InstantSearch 小部件</a>。</p><div class="kg-card kg-callout-card kg-callout-card-grey"><div class="kg-callout-emoji"> ⚛️</div><div class="kg-callout-text">更喜欢反应？阅读我们关于<a href="https://blog.meilisearch.com/instant-meilisearch/">将 InstantSearch 与 React 结合使用的</a>教程。</div></div><h2 id="9-limited-cloud-support"> 9. 有限的云支持</h2><p>外包服务器的配置、维护和扩展是云时代的常见策略。团队可以专注于为用户提供价值，而不是管理服务器。与其他数据库一样，Postgres 可用于广泛的托管服务云产品。不幸的是，托管服务通常有局限性。</p><p>对于 Postgres，实现最先进的全文搜索需要安装扩展。此外，微调语言词典和更多配置需要访问文件系统。不幸的是，这意味着许多功能在云环境中不可用。</p><p>为了实现基础架构的委派，搜索引擎通常会提供<a href="https://blog.meilisearch.com/meilisearch-cloud-general-availability/">专用的云服务</a>。这些定制平台不会妥协并允许使用完整的搜索功能。此外，客户可以受益于为他们的搜索用例量身定制的优质 SLA、支持和其他企业服务。</p><hr><p> Postgres 是一个伟大的、灵活的数据库，允许实施许多定制的、一体化的解决方案。它的全文搜索功能对于基本搜索来说可能已经足够了，但在涉及到相关性问题的实时搜索时就显得不够用了。这些限制在大型数据集上变得更糟。这是很自然的，因为 Postgres 是一个数据库，而不是搜索引擎。</p><p> Meilisearch 是一个开源搜索引擎，用于构建快速且相关的搜索体验。它旨在为最终用户提供最先进的体验，同时提供简单直观的开发人员体验。您可以<a href="https://www.meilisearch.com/docs/learn/getting_started/quick_start?ref=blog.meilisearch.com">在本地运行美丽搜索</a>或<a href="https://cloud.meilisearch.com/login?ref=blog.meilisearch.com">在美丽搜索云上免费</a>创建一个账号来试用。</p><p><strong>加入关于<a href="https://www.reddit.com/r/webdev/comments/13phe7h/nine_reasons_why_postgres_might_not_be_good/?ref=blog.meilisearch.com">r/webdev</a>和<a href="https://news.ycombinator.com/newest?next=36041017&amp;ref=blog.meilisearch.com">Hacker News 的</a>讨论。</strong></p><p>更多美丽搜索内容，您可以加入<a href="https://discord.gg/meilisearch/?ref=blog.meilisearch.com">Discord</a>社区或订阅<a href="https://meilisearch.us2.list-manage.com/subscribe?u=27870f7b71c908a8b359599fb&amp;id=79582d828e&amp;ref=blog.meilisearch.com">时事通讯</a>。您可以通过查看<a href="https://roadmap.meilisearch.com/?ref=blog.meilisearch.com">路线图</a>和参与<a href="https://github.com/meilisearch/product/discussions?ref=blog.meilisearch.com">产品讨论</a>来了解有关该产品的更多信息。</p> ]]>; </content:encoded></item><item><title><![CDATA[Markus Machatschek: POV of a long-time Meilisearch contributor]]></title><description><![CDATA[We had the pleasure of speaking with Markus, a long-time contributor to Meilisearch, to learn about his experience with the product, its evolution over time, and his vision for its future.  ]]></description><link/> https://blog.meilisearch.com/meilistar-interview-markus-machatschek/<guid ispermalink="false"> 645a34613b8de30001a06456 </guid><category><![CDATA[Community]]></category><dc:creator><![CDATA[Carolina Ferreira]]></dc:creator><pubDate> Mon, 15 May 2023 07:47:29 GMT</pubDate> <media:content medium="image" url="https://blog.meilisearch.com/content/images/2023/05/63.png"></media:content><content:encoded><![CDATA[<h2 id="meet-markus">认识马库斯</h2><img src="https://blog.meilisearch.com/content/images/2023/05/63.png" alt="Markus Machatschek：长期 Meil​​isearch 贡献者的 POV"><p>为了拉开序幕，我们请马库斯自我介绍。</p><blockquote> “我是 Markus， <a href="https://devjobs.at/?ref=blog.meilisearch.com">devjob.at</a>的一名软件开发人员。我喜欢尝试新技术和软件包、原型设计和改进代码库。我的主要兴趣领域在于后端和基础架构主题。在空闲时间，我阅读了很多技术文章并关注 Tech Twitter 以了解我们不断变化的开发世界中有什么新鲜事。”</blockquote><p>你可以在 Twitter 上找到他<a href="https://twitter.com/m4ch4tschek?ref=blog.meilisearch.com">@m4ch4tschek</a></p><blockquote> “除了技术之外，我还喜欢在大自然中度过时光。自从养了一只狗，我就对驯狗产生了兴趣。我为此投入了大量时间，并认为这些时间花得值。”</blockquote><p>好奇的人想知道！我们忍不住询问帐户建议。如果你也很想知道，别担心，这是 Markus 的顶级 Twitter 帐户列表：</p><ul><li> <a href="https://twitter.com/marcelpociot?ref=blog.meilisearch.com">@marcelpociot</a> ：Markus 称赞 Marcel Pociot 围绕 Laravel 和其他项目创建了最好的开发人员工具，并为开发人员的问题快速提供了可行的解决方案。</li><li> <a href="https://twitter.com/jackellis?ref=blog.meilisearch.com">@JackEllis</a> ：他发现 Jack Ellis 作为首席技术官挑战谷歌分析业务的旅程非常鼓舞人心。</li><li> <a href="https://twitter.com/mathemagic1an?ref=blog.meilisearch.com">@mathemagic1an</a> ：这个帐户涵盖了 AI 的所有内容，他将它推荐给对该领域感兴趣的任何人。</li><li> <a href="https://twitter.com/mattpocockuk?ref=blog.meilisearch.com">@mattpocockuk</a> ：Markus 认为这个帐户所有者拥有“TypeScript 超能力”</li><li> <a href="https://twitter.com/tobias_petry?ref=blog.meilisearch.com">@tobias_petry</a> ：对于 SQL 内容，他建议关注 Tobias</li><li> <a href="https://twitter.com/mjackson?ref=blog.meilisearch.com">@mjackson</a>和<a href="https://twitter.com/kentcdodds?ref=blog.meilisearch.com">@kentcdodds</a>因与 Remix 的合作而被推荐</li></ul><p>当然，他也建议关注<a href="https://twitter.com/meilisearch?ref=blog.meilisearch.com">@meilisearch</a> 😎</p><h2 id="love-at-first-sight">一见钟情</h2><p>Markus 在 2020 年底发现了美丽搜索。虽然他不记得他是如何第一次听说美丽搜索的，但他确实记得被它的简单所吸引：</p><blockquote> “终于有了一些快速且可配置的东西，我无需博士学位也能轻松理解和部署。”</blockquote><p>他最终将它实施到两个项目中，其中之一， <a href="https://en.devworkplaces.com/?ref=blog.meilisearch.com">DEVWorkplaces</a> ，在我们的<a href="https://mailchi.mp/meilisearch/newsletter-6025733?e=%5BUNIQID%5D&amp;ref=blog.meilisearch.com">时事通讯</a>中得到了强调。 DEVWorkplaces 专注于 DACH 地区的求职和开发工作场所发现。它已经在生产中使用 Algolia，但它并不能完全满足产品的需求。</p><p>当被问及 Meil​​isearch 有哪些 Algolia 无法提供的功能时，Markus 列出了一些关键优势。首先，<strong>美力搜索提供了自托管选项</strong>，这对他的团队来说是一大优势。其次，他很欣赏<strong>当地的发展环境</strong>，以及美丽搜索是开源的。最后，Markus 发现美力搜索<strong>对团队成员来说易于使用和理解</strong>，使其成为每个相关人员都更容易使用的工具。</p><p>我们很想知道 Markus 对美力搜索从 2020 年到 2023 年的发展历程的看法。美力搜索是从优秀走向卓越，还是变得更糟？值得庆幸的是，美丽搜索似乎已经朝着正确的方向发展了😀</p><blockquote> “看到社区成长是最重要的一点。越来越多地采用框架/语言集成。此外，现在有更多的团队成员。从发布、产品决策到沟通、博客文章和社区互动，一切都变得更加专业（以一种好的方式）。”</blockquote><p>作为一名开发者倡导者和最早的团队成员之一，我很高兴听到这样的话！事实上，美丽搜索的每个人都为我们取得的成就感到自豪，并对未来充满期待！看到有人从一开始就支持我们，我们很感动🥰</p><h2 id="from-user-to-contributor">从用户到贡献者</h2><p>我们总是对个人如何跃跃欲试地为项目做出贡献感到好奇。就马库斯而言，这是迫不得已的事情。当他遇到问题时，他别无选择，只能自己解决。随着他越来越多地参与开源项目，Markus 开始为<a href="https://github.com/meilisearch/meilisearch?ref=blog.meilisearch.com">Meil​​isearch</a>和<a href="https://github.com/keystonejs/keystone?ref=blog.meilisearch.com">KeystoneJS</a>做贡献，这两个项目是他在工作中使用的。</p><blockquote> “由于开源项目主要依赖于用户贡献，因此这是可行的方法。此外，为开源项目（无论大小）做贡献是我喜欢的事情，尽管我想贡献更多。”</blockquote><p> Markus 的贡献随着时间的推移而演变。尽管他仍然致力于代码修复，但他更多地参与了非编码任务。 Markus 对<a href="https://github.com/laravel/scout?ref=blog.meilisearch.com">Laravel Scout</a>相关的问题特别感兴趣，并尽可能提供有用的答案。他还一直积极参与产品讨论。</p><blockquote> “我订阅了一些主题，这些主题让我每天使用美丽搜索更轻松。 <a href="https://github.com/gmourier/?ref=blog.meilisearch.com">Guillaume Mourier</a> （美丽搜索的产品经理）努力收集尽可能多的关于新功能或变化的信息。这很棒，因为我们（贡献者和用户）可以在任何产品决策实施之前添加输入。”</blockquote><p>正是这样的反馈帮助我们不断改进美丽搜索，我们感谢 Markus 和我们社区的贡献。我们很高兴能根据他和我们社区的意见继续改进我们的产品。这就是为什么我们向他询问了他希望在不久的将来看到的功能，他没有让我们失望！他有很多想法：</p><blockquote> “我认为，如果美力搜索<a href="https://github.com/meilisearch/product/discussions/213?ref=blog.meilisearch.com">无需创建转储并重新导入即可升级</a>，那就太好了。只需关闭 Meil​​isearch 并使用较新版本启动它。目前，如果我们想要实现零停机部署（拥有旧的 Meil​​isearch 实例和一个新实例并将更改同步到两个实例，直到所有内容都是最新的），这会导致搜索端点的停机时间延长和实施开销边。”</blockquote><blockquote> “此外，对于我目前的工作项目，我们希望<a href="https://github.com/meilisearch/product/discussions/508?ref=blog.meilisearch.com">多地理点</a>支持。由于缺少此功能，我们需要使用独特的属性功能，不幸的是，它在搜索请求中非常慢，而且命中率很高。”</blockquote><p>与 Markus 聊天并了解他在美力搜索的体验非常棒。很高兴收到我们社区成员的来信并了解他们使用美力搜索的各种方式。我们感谢 Markus 花时间与我们分享他的想法和经验，我们期待继续与他和我们的社区合作，创造快速、强大和可靠的搜索体验。</p><p>如果您有兴趣了解更多有关其他开发人员和组织如何使用 Meil​​isearch 的信息，请查看我们<a href="https://blog.meilisearch.com/meilistar-interview-minoru-osuka/">之前的 Meil​​istar 采访</a>Minoru Osuka，我们的主要语言贡献者之一。</p> ]]>; </content:encoded></item><item><title><![CDATA[Squeezing millions of documents in 128 TB of virtual memory]]></title><description><![CDATA[How dynamic management of virtual memory enabled us to remove limitations in Meilisearch indexing policy.]]></description><link/> https://blog.meilisearch.com/dynamic-virtual-address-management/<guid ispermalink="false"> 645383ccb5c89700019cc994</guid><dc:creator><![CDATA[Louis Dureuil]]></dc:creator><pubDate> Tue, 09 May 2023 07:10:15 GMT</pubDate> <media:content medium="image" url="https://blog.meilisearch.com/content/images/2023/05/58.png"></media:content><content:encoded><![CDATA[<img src="https://blog.meilisearch.com/content/images/2023/05/58.png" alt="Squeezing millions of documents in 128 TB of virtual memory"><p>程序可以向操作系统请求多少虚拟内存？当然，不会超过机器中安装的 RAM 数量？我们可以向其中添加配置的<a href="https://wiki.archlinux.org/title/Swap?ref=blog.meilisearch.com#Swap_space">交换</a>或<a href="https://learn.microsoft.com/en-us/troubleshoot/windows-client/performance/introduction-to-the-page-file?ref=blog.meilisearch.com#physical-extension-of-ram">页面文件</a>的数量？等等——它是否也取决于其他进程使用了​​多少内存？</p><p>美力搜索历经艰辛，找到了这些问题的准确答案。在本文中，我们将分享我们对虚拟内存的了解，以及它如何以令人惊讶的微妙方式与应用程序交互。</p><p> Meilisearch 是一个<a href="https://github.com/meilisearch/meilisearch/?ref=blog.meilisearch.com">开源</a>搜索引擎，旨在以极少的集成工作提供闪电般快速、高度相关的搜索。它可以将文档以称为<a href="https://docs.meilisearch.com/learn/core_concepts/indexes.html?ref=blog.meilisearch.com">索引的</a>组的形式存储在磁盘上，并搜索这些索引以获取与每个查询相关的文档。</p><p>在<a href="https://blog.meilisearch.com/whats-new-in-v1-1/">美丽搜索 v1.1</a>中，我们取消了对索引数量和最大大小的限制。在本文中，我们将分享动态虚拟内存管理如何成为实现这些改进的关键。 </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.meilisearch.com/content/images/2023/05/image1-1.jpg" class="kg-image" alt="在 128 TB 虚拟内存中压缩数百万文档" loading="lazy" width="664" height="500" srcset="https://blog.meilisearch.com/content/images/size/w600/2023/05/image1-1.jpg 600w, https://blog.meilisearch.com/content/images/2023/05/image1-1.jpg 664w"><figcaption><a href="https://knowyourmeme.com/memes/slaps-roof-of-car?ref=blog.meilisearch.com">汽车推销员模因</a>，但汽车是 Linux 进程的虚拟地址空间</figcaption></figure><h2 id="virtual-memory-and-the-limits-it-imposed-on-meilisearch">虚拟内存及其对美力搜索的限制</h2><h3 id="what-is-virtual-memory">什么是虚拟内存？</h3><p>虚拟内存是由操作系统 (OS) 创建的用于管理物理内存的抽象概念。这种抽象允许操作系统为正在运行的进程提供虚拟地址空间。每个进程的虚拟地址空间都与其他进程隔离。这样，可以防止一个进程意外（或恶意）访问属于另一个进程的内存。这与所有可以直接访问物理内存的进程形成对比，就像旧操作系统中的历史情况一样，并且在某些嵌入式系统中仍然是这种情况。</p><p>操作系统通过将应用程序操作的虚拟内存页面转换为物理内存中的对应部分来实现虚拟内存。</p><p>虚拟内存还使操作系统能够实现一种称为<em>交换</em>（也称为<em>页面文件</em>）的机制。通过将虚拟内存页面映射到较慢的磁盘存储内存，以便在下一次访问该页面时重新加载到物理内存中，虚拟内存还提供了一个寻址比实际可用内存更多的内存的方法。</p><p>下图显示了两个进程的虚拟内存示例，其中每个进程只能访问操作系统分配给它的物理内存部分。进程 A 的一页在磁盘上被“换出”，并在下次访问时从磁盘加载到物理内存。 </p><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://blog.meilisearch.com/content/images/2023/05/image2-1.png" class="kg-image" alt="在 128 TB 虚拟内存中压缩数百万文档" loading="lazy" width="1999" height="1190" srcset="https://blog.meilisearch.com/content/images/size/w600/2023/05/image2-1.png 600w, https://blog.meilisearch.com/content/images/size/w1000/2023/05/image2-1.png 1000w, https://blog.meilisearch.com/content/images/size/w1600/2023/05/image2-1.png 1600w, https://blog.meilisearch.com/content/images/2023/05/image2-1.png 1999w" sizes="(min-width: 720px) 720px"><figcaption>虚拟地址转换的简化表示</figcaption></figure><h3 id="virtual-memory-in-meilisearch">美里搜索中的虚拟内存</h3><p>在 Unix 环境中，您可以使用<code>htop</code>等命令行界面工具来查看进程使用了​​多少虚拟内存。以下是 Meil​​isearch 实例的命令输出： </p><figure class="kg-card kg-image-card"><img src="https://blog.meilisearch.com/content/images/2023/05/image3-1.png" class="kg-image" alt="在 128 TB 虚拟内存中压缩数百万文档" loading="lazy" width="1999" height="469" srcset="https://blog.meilisearch.com/content/images/size/w600/2023/05/image3-1.png 600w, https://blog.meilisearch.com/content/images/size/w1000/2023/05/image3-1.png 1000w, https://blog.meilisearch.com/content/images/size/w1600/2023/05/image3-1.png 1600w, https://blog.meilisearch.com/content/images/2023/05/image3-1.png 1999w" sizes="(min-width: 720px) 720px"></figure><p>如您所见，美丽搜索使用了高达 8593GB 的虚拟内存——远远超过本机可用的物理内存 (16GB) 和磁盘 (1000GB)。虚拟内存可以为进程提供<em>几乎</em>无限的内存。请注意，<em>物理</em>内存使用量（实际 RAM）要低得多，仅使用了 38464KB。</p><p>负责美力搜索虚拟内存使用的主要是<strong>内存映射</strong>，其中操作系统将文件内容映射到虚拟内存。 Meilisearch 使用<a href="https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database?ref=blog.meilisearch.com">LMDB</a>键值存储将存储在磁盘上的索引内容映射到虚拟内存。这样，对索引文件的任何读取或写入操作都是通过虚拟内存缓冲区进行的。操作系统透明高效地交换物理内存和磁盘之间的内存页。</p><p>现在，问题是这样的内存映射文件可以占用虚拟地址空间的相当大一部分。当映射一个 10GB 的文件时，您本质上需要一个相应的 10GB 的连续虚拟内存缓冲区。</p><p>此外，在创建映射时必须指定可以通过内存映射写入文件的最大大小，以便操作系统可以确定用于映射的连续虚拟内存缓冲区的大小。</p><p>回到我们在美丽搜索中使用的 8593GB 虚拟内存，我们现在了解到其中大部分实际上是用于创建文档索引的内存映射。 Meilisearch分配那么多内存来确保这些内存映射足够大以适应磁盘上索引的增长。</p><p>但极限是什么？一个进程的虚拟内存可以增长多少？结果，可以同时存在多少个索引，最大大小是多少？</p><h3 id="128tb-can-only-fit-so-many-indexes"> 128TB只能放这么多索引！</h3><p>理论上，在 64 位计算机上，虚拟地址空间为 2^64 字节。那是 18.45 艾字节。超过 1600 万太字节！但实际上，操作系统专用于进程的虚拟地址空间要小得多： <a href="https://www.kernel.org/doc/html/latest/x86/x86_64/mm.html?ref=blog.meilisearch.com">Linux 上为 128TB</a> ， <a href="https://techcommunity.microsoft.com/t5/windows-blog-archive/pushing-the-limits-of-windows-virtual-memory/ba-p/723750?ref=blog.meilisearch.com">Windows 上为 8TB</a> 。</p><p> 128TB 听起来可能很多。但是在美丽搜索实例可以使用的索引数量 (N) 和索引的最大大小 (M) 之间需要权衡。基本上，我们需要 N * M 才能保持在 128TB 限制以下。随着文档索引有时会超过数百 GB，这可能是一个挑战。</p><p>在美丽搜索 v1.0 之前的版本中，这种权衡是通过<code>--max-index-size</code> CLI 参数公开的。这允许开发人员定义每个索引的映射大小，默认值为 100GB。对于这些以前的版本，如果您希望索引大于 100GB，则需要将<code>--max-index-size</code>的值更改为索引所需的<em>估计</em>最大大小。</p><p>因此，虽然这并不明显，但更改<code>--max-index-size</code>参数的值会限制 Meil​​isearch 实例可以使用的索引数量：在 Linux 上大约 1000 个默认值为 100GB 的索引，在 Windows 上大约 80 个。增加参数以容纳更大的索引会减少索引的最大数量。例如，1TB 的最大索引大小会将您限制为 100 个索引。</p><p>那么如何决定<code>--max-index-size</code>的值呢？没有直接的答案。因为 Meil​​isearch 构建了称为倒排索引的数据结构，其大小取决于以非平凡方式索引的文本的特征。因此，指数的规模很难事先估计。</p><p>将这个带有微妙后果的决定留在用户手中感觉就像它违背了我们拥有一个简单、可用的引擎和良好默认值的目标。随着<a href="https://blog.meilisearch.com/v1-enterprise-ready-stable/">v1.0 即将发布</a>，我们不想稳定<code>--max-index-size</code>参数。因此我们决定在 v1.0 中删除此选项。我们暂时将索引的内存映射大小硬编码为 500GB，计划在 v1.1 版本中提供更直观的解决方案。</p><p>进入动态虚拟地址空间管理。</p><h2 id="to-infinity-and-beyond-with-dynamic-virtual-address-space-management">通过动态虚拟地址空间管理走向无限和超越</h2><h3 id="analogy-with-dynamic-arrays">类比动态数组</h3><p>让我们将手头的问题与固定大小的数组进行比较。在编译语言中，固定大小的数组需要开发人员在编译时定义它们的大小，因为它不能在运行时更改。使用已弃用的<code>--max-index-size</code>参数，美力搜索用户面临类似的限制。他们必须确定最佳索引大小，在索引大小和索引总数之间进行折衷。</p><p>真正使这个问题无法解决的是索引的两个相互竞争的用例：</p><ul><li>在索引中存储大量大文档，因此索引达到数百GB；</li><li>存储许多索引，可能有数千个（尽管这通常旨在解决多租户问题，这应该使用 <a href="https://docs.meilisearch.com/learn/security/tenant_tokens.html?ref=blog.meilisearch.com">租户令牌</a>来实现）。</li></ul><p>用户基本上面临两难境地：拥有较大的索引大小但限制索引的数量或限制索引大小以允许更多索引。我们必须想出更好的办法。</p><p>在编译语言中，当数组的大小时无法事先知道时，开发人员会使用动态数组。 A dynamic array is a data structure composed of three bits of information:</p><ul><li> a pointer to a dynamically allocated contiguous array;</li><li> the size allocated to this array, denoted as the capacity;和</li><li>the current number of elements stored in the array.</li></ul><p> Adding an element to a dynamic array requires checking the remaining capacity of the array. If the new elements are too big for the existing array, the array is reallocated with a bigger capacity to avoid overflow. Most system languages provide an implementation of dynamic arrays as part of their standard library ( <a href="https://doc.rust-lang.org/std/vec/index.html?ref=blog.meilisearch.com">Rust</a> , <a href="https://en.cppreference.com/w/cpp/container/vector?ref=blog.meilisearch.com">C++</a> ).</p><h3 id="step-1-start-small-and-resize-as-needed"> Step 1: Start small and resize as needed</h3><p> Following our array analogy, a first step towards alleviating the trade-off between the number and size of indexes would be to dynamically resize indexes when their memory map is full, increasing the capacity of the memory map in the process.</p><p> In Meilisearch, we can implement a similar behavior by resizing the index when the index map is full.</p><p> We added this logic to the index scheduler responsible for managing the indexes of a Meilisearch instance. It handles changes to indexes, such as new document imports, settings updates, etc. In particular, we updated the <code><a href="https://github.com/meilisearch/meilisearch/blob/35f6c624bc5fd2c55598a61cfdcf286a44983e41/index-scheduler/src/lib.rs?ref=blog.meilisearch.com#L929">tick</a></code> <a href="https://github.com/meilisearch/meilisearch/blob/35f6c624bc5fd2c55598a61cfdcf286a44983e41/index-scheduler/src/lib.rs?ref=blog.meilisearch.com#L929">function</a> , responsible for running tasks, to handle the <a href="https://github.com/meilisearch/meilisearch/blob/35f6c624bc5fd2c55598a61cfdcf286a44983e41/index-scheduler/src/lib.rs?ref=blog.meilisearch.com#L1021"><code>MaxDatabaseSizeReached</code></a> error. As the name implies, this error is returned when a batch of tasks fails due to the memory map associated with an index being too small to accommodate the results of the write operations performed during that batch.</p><p> See how we implemented this in Rust:</p><pre> <code class="language-rust">// When you get the MaxDatabaseSizeReached error: // 1. identify the full index // 2. close the associated environment // 3. resize it // 4. re-schedule tasks Err(Error::Milli(milli::Error::UserError( milli::UserError::MaxDatabaseSizeReached, ))) if index_uid.is_some() =>; { // Find the index UID associated with the current batch of tasks. let index_uid = index_uid.unwrap(); // Perform the resize operation for that index. self.index_mapper.resize_index(&amp;wtxn, &amp;index_uid)?; // Do not commit any change we could have made to the status of the task batch, since the batch failed. wtxn.abort().map_err(Error::HeedTransaction)?; // Ask the scheduler to keep processing, // which will cause a new attempt at processing the same task, // this time on the resized index. return Ok(TickOutcome::TickAgain(0)); }</code></pre><p> The error is handled by resizing the index. It is implemented in the <a href="https://github.com/meilisearch/meilisearch/blob/35f6c624bc5fd2c55598a61cfdcf286a44983e41/index-scheduler/src/index_mapper.rs?ref=blog.meilisearch.com#L197"><code>IndexMapper::resize_index</code></a> function, a simplified implementation of which is given below:</p><pre> <code class="language-rust">/// Resizes the maximum size of the specified index to the double of its current maximum size. /// /// This operation involves closing the underlying environment which can take a long time to complete. /// Other tasks will be prevented from accessing the index while it is being resized. pub fn resize_index(&amp;self, rtxn: &amp;RoTxn, uuid: Uuid) ->; Result&lt;()>; { // Signal that will be sent when the resize operation completes. // Threads that request the index will wait on this signal before reading from it. let resize_operation = Arc::new(SignalEvent::manual(false)); // Make the index unavailable so that other parts of code don&#39;t accidentally attempt to open it while it is being resized. let index = match self.index_map.write().insert(uuid, BeingResized(resize_operation)) { Some(Available(index)) =>; index, _ =>; panic!(&quot;The index is already being deleted/resized or does not exist&quot;), }; // Compute the new size of the index from its current size. let current_size = index.map_size()?; let new_size = current_size * 2; // Request to close the index. This operation is asynchronous, as other threads could be reading from this index. let closing_event = index.prepare_for_closing(); // Wait for other threads to relinquish the index. closing_event.wait(); // Reopen the index with its new size. let index = self.create_or_open_index(uuid, new_size)?; // Insert the resized index self.index_map.write().unwrap().insert(uuid, Available(index)); // Signal that the resize operation is complete to threads waiting to read from the index. resize_operation.signal(); Ok(()) }</code></pre><p> As you can see, the implementation is made more complex because indexes can be requested at any time by other threads with read access. However, at its core, the implementation is similar to the capacity increase of a dynamic array.</p><p> Under this new scheme, an index would start its life with a small size — say, a couple of GBs — and would be dynamically resized upon needing more space, allowing us to address any of the two competing use cases outlined above.</p><p> We could have called it a day and gone home (well, technically no, because we&#39;re <a href="https://blog.meilisearch.com/remote-work-is-the-future-of-work/">working remotely</a> , but that&#39;s unrelated), but this solution still suffers from two remaining issues:</p><ol><li> What if we want to address <em>both</em> use cases simultaneously, ie having a lot of indexes <em>and</em> big-sized indexes?</li><li> Since we depend on the <code>MaxDatabaseSizeReached</code> error to know if an index needs resizing, we discard all progress made by the batch up to this point. This means starting over again on the resized index, and basically multiplying the duration of indexing operations.</li></ol><p> We wondered how to address these issues. In the next section, we&#39;ll see how we handled this, as well as the new edge cases introduced by further iterations.</p><h3 id="step-2-limit-the-number-of-concurrently-opened-indexes"> Step 2: Limit the number of concurrently opened indexes</h3><p> The first step in addressing the issues above is finding a way to limit the total virtual memory used by all indexes. Our assumption was that we should not have all the indexes mapped in memory at the same time. By limiting the number of simultaneously opened indexes to a small number, we could afford to allocate a large portion of virtual memory to each of them.</p><p> This was implemented using a <a href="https://github.com/meilisearch/meilisearch/blob/80b060f920efdfcf8ed65b421b0bca070fac8eed/index-scheduler/src/lru.rs?ref=blog.meilisearch.com">simplified Least Recently Used (LRU) cache</a> with the following characteristics:</p><ul><li> Insertion and retrieval operations are done in linear time, as opposed to the usual constant time. This does not matter, considering we&#39;re storing a very small number of elements whose keys have a performant equality comparison function (UUID).</li><li> It can be accessed from multiple readers without blocking. In Rust terminology, it means that the data structure is <code>Send</code> and <code>Sync</code> , and its functions to retrieve an element accept a shared reference ( <code>&amp;self</code> ). We benefit from this characteristic by putting the cache behind a <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html?ref=blog.meilisearch.com"><code>RwLock</code></a> .</li><li> The cache uses a generation number to track access to items. Looking for an item only entails bumping its generation number to the latest generation number known to the cache. Evicting an item when the cache is full is done by linearly searching the cache for the minimal generation number, which is the oldest accessed item. This simple implementation was possible without relying on <code>unsafe</code> , which protects the implementation from the risk of memory safety errors.</li></ul><p> With this cache, we limit the number of simultaneously opened indexes to, for example, 20. An index on a Linux machine could grow to 2TB before running out of virtual space. And running out of space would mean that the total 20 indexes would somehow be larger than 128TB on disk, which is quite a lot by today&#39;s standards, considering that <a href="https://www.techradar.com/news/at-100tb-the-worlds-biggest-ssd-gets-an-eye-watering-price-tag?ref=blog.meilisearch.com">a 100TB SSD was $40,000 in 2020</a> . If you do run into an issue caused by the size of your cumulated opened indexes being higher than 128TBs, please feel free to contact us 😎</p><h3 id="what-if-we-started-with-a-big-index-size"> What if we started with a big index size?</h3><p> Now that the LRU allows us to accommodate memory mappings of 2TB without limiting the total number of indexes, the easy way to solve our resize performance problem is to have all indexes start with a map size of 2TB. Please note that creating a map size of 2TB does not cause a file of 2TB to be created on disk, as only the amount of documents and indexed data cause the disk file to grow. Should one index actually grow beyond 2TB, the resizing mechanism would be there to make it work. But that remains unlikely. With the cache ensuring we cannot have more than 20 indexes <em>mapped</em> at the same time, we can have as many indexes of arbitrary size as we want without paying any resize penalty.</p><p> The only remaining hurdle in this scheme is that for some OSes, the available virtual address space is much, <em>much</em> smaller than 128TB. <a href="https://github.com/meilisearch/meilisearch/issues/3488?ref=blog.meilisearch.com">Cue an issue</a> opened by a user not having even 500GBs of virtual memory to allocate to a single index in v1.0. To address these edge cases, and also the matter of Windows, which only advertises 8TB of virtual memory for a process, we decided to measure at runtime the amount of virtual memory that we can memory map.</p><p> <a href="https://twitter.com/lodurel/status/1625143013453201411?ref=blog.meilisearch.com">We couldn&#39;t find</a> a way to achieve this that was both fast and portable. We decided to take advantage of the existing portability provided by <a href="https://en.wikipedia.org/wiki/Lightning_Memory-Mapped_Database?ref=blog.meilisearch.com">LMDB</a> (the open-source key-value store we&#39;re using to store indexes) and also the part of our stack that relies on memory mapping. We ended up implementing a dichotomic search on the maximum map size that an index can be opened with.</p><p> By doing this dichotomic search, we measured an actual budget for allocations closer to 93TB on Linux and between 9 and 13TB for Windows (which is surprising because it is <em>more</em> than advertised!). The Linux difference we measure can be explained by the virtual address space being shared between all allocations from the process, not only the environment mapping. Since the allocation needs to be contiguous, a single small allocation can cause fragmentation and reduce the contiguously available virtual memory.</p><p> The implementation of dichotomic search can be found in the <a href="https://github.com/meilisearch/meilisearch/blob/71e7900c674ea8500c5b27707608acf1f2ea5930/index-scheduler/src/lib.rs?ref=blog.meilisearch.com#L432"><code>IndexScheduler::index_budget</code></a> function. It either computes how many indexes of 2TB can be opened simultaneously or, if less than 2TB are available, how big a single index could be. For performance reasons, this dichotomic budget computation is skipped if at least 80TB (6TB for Windows) can be mapped, as we consider that we have enough space in that case.</p><h2 id="conclusion">结论</h2><p>The unfortunate trade-off between the number of indexes and their maximum size caused us to switch from a statically chosen max index size to a dynamic virtual address space management scheme. Meilisearch now starts by computing how many indexes of 2TB can be opened simultaneously without overflowing the virtual memory. Then, it uses an LRU cache of that many indexes opened with a map size of 2TB. Thanks to this, if an index ever goes over the 2TB limit, it is properly resized.</p><p> We had to perform this change in two steps. First, by removing the <code>--max-index-size</code> CLI option because we did not want to stabilize it with v1. Then, we had to design a transparent way for users to manage indexes v1.1. This is an example of the <a href="https://blog.meilisearch.com/planning-v1-and-beyond/">planning that went into v1</a> .</p><p> This work also benefited from our new process to release prototypes, which allowed benevolent users such as <a href="https://github.com/newdev8?ref=blog.meilisearch.com"><strong>newdev8</strong></a> to <a href="https://github.com/meilisearch/meilisearch/issues/3488?ref=blog.meilisearch.com">help us check</a> that the changes worked in their configuration. We are grateful for their contribution 🤗</p><p> Here&#39;s a table summarizing the various virtual address space management schemes discussed in this article:</p><!--kg-card-begin: html--><table><tr><th> Scheme</th><th> Version range</th><th> Index max size</th><th> Index max count (Linux)</th><th> Supports small address space</th><th> Index resize</th><th>评论</th></tr><tr><td><code>--max-index-size</code></td><td> Before v1.0</td><td> Defined at startup</td><td> 128 TB divided by <code>--max-index-size</code></td><td> Yes with proper argument value</td><td>绝不</td><td>Unintuitive tradeoff</td></tr><tr><td> 500 GB</td><td> v1.0.x</td><td> 500 GB</td><td> About 200</td><td>不</td><td>绝不</td><td>Temporary for v1.0</td></tr><tr><td> Index resize, small index size</td><td> prototype-unlimited-index-0</td><td> 128 TB</td><td> About 12,000 with original size</td><td>是的</td><td>Frequent</td><td> Performance regression</td></tr><tr><td> Index resize + LRU, big index size</td><td> v1.1.x and up</td><td> 128 TB</td><td>无限</td><td>是的</td><td>Never for indexes under 2 TB</td><td> Current “ideal” solution</td></tr></table><!--kg-card-end: html--><p> Here are some existing limitations in Meilisearch that we could work on to further improve the scheme:</p><ul><li> An index always uses one slot in the LRU regardless of its size. For indexes bigger than 2 TB, this can lead to allocation errors.</li><li> When an index is requested, it is opened before evicting any index if the cache is full. This forces us to reserve a slot for freshly opened indexes and could conceivably cause transient allocation errors if many fresh indexes are requested simultaneously.</li><li> This implementation requires code that reads indexes to relinquish them as fast as possible and to not open a given index twice during the same task; failure to uphold this could cause deadlocks.</li><li> Tasks that iterate on all indexes became slower, especially on some platforms (macOS), which led us to add cache for some of them (see, for instance, <a href="https://github.com/meilisearch/meilisearch/pull/3541?ref=blog.meilisearch.com">this PR</a> .)</li></ul><p> And it&#39;s a wrap! Join the discussion on <a href="https://www.reddit.com/r/rust/comments/13ciq47/how_dynamic_virtual_address_management_helps_us/?ref=blog.meilisearch.com">/r/rust</a> and <a href="https://news.ycombinator.com/item?id=35871232&amp;ref=blog.meilisearch.com">Hacker News</a> .</p><p> For more things Meilisearch, join us on <a href="https://discord.gg/meilisearch/?ref=blog.meilisearch.com">Discord</a> or subscribe to our <a href="https://meilisearch.us2.list-manage.com/subscribe?u=27870f7b71c908a8b359599fb&amp;id=79582d828e&amp;ref=blog.meilisearch.com">newsletter</a> . You can learn more about our product by checking out our <a href="https://roadmap.meilisearch.com/?ref=blog.meilisearch.com">roadmap</a> and participating in our <a href="https://github.com/meilisearch/product/discussions?ref=blog.meilisearch.com">product discussions</a> .</p> ]]>;</content:encoded></item></channel></rss>